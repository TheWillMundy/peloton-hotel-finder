"use client";

// React and Next.js imports
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';

// Third-party library imports
import { ChevronLeft } from 'lucide-react';
import type { Map as MapboxMapType } from 'mapbox-gl';
import { LngLatBounds } from 'mapbox-gl';
import { useQuery, keepPreviousData } from '@tanstack/react-query';

// Context imports
import { SearchProvider, useSearch, ZOOM_LEVELS } from '@/app/contexts/SearchContext';
import { UIInteractionProvider, useUIInteraction } from '@/app/contexts/UIInteractionContext';

// UI component imports
import { Button } from '@/app/components/ui/button';
import BottomSheet from '@/app/components/ui/BottomSheet';
import type { BottomSheetHandle, BottomSheetState } from '@/app/components/ui/BottomSheet';

// Map component imports
import MapboxMap from '@/app/components/map/MapboxMap';

// Hotel component imports
import HotelDetailModal from '@/app/components/hotel/HotelDetailModal';
import HotelListPanel from '@/app/components/hotel/HotelListPanel';

// Filter component imports
import FilterPanel from '@/app/components/filter/FilterPanel';
import FilterModal from '@/app/components/filter/FilterModal';
import type { Filters } from '@/app/components/filter/FilterChips';

// Type imports
import type { ClientHotel } from '@/lib/pelotonAPI';
import type { MapboxGeocodingFeature } from '@/app/components/search/CitySearchInput';

// Utility imports
import { cn, cubicBezier } from '@/lib/utils';

// Dynamically imported components
const CitySearchInput = dynamic(() => import('@/app/components/search/CitySearchInput'), { ssr: false });

// Define primary loyalty programs, could also be imported from FilterChips if kept there
const PRIMARY_LOYALTY_PROGRAMS = [
  "Accor Le Club", "Best Western Rewards", "Choice Privileges", "Hilton Honors", 
  "IHG Rewards Club", "Marriott Bonvoy", "Radisson Rewards", "World of Hyatt", "Wyndham Rewards"
];

const MOBILE_BREAKPOINT = 768;
const DESKTOP_SIDEBAR_WIDTH_PERCENTAGE = 33.33; // Changed from fixed 420px to percentage
const MOBILE_SEARCH_BAR_HEIGHT = 60; // Approximate height for the search bar on mobile

// New Interface for unified map focus state management
interface MapFocusState {
  type: 'idle' | 'city_overview' | 'match_found' | 'poi_no_match' | 'hover_focus';
  centerCoordinates: [number, number]; // lng, lat
  zoomLevel: number;
  focusedHotelId?: number | null; // For 'match_found' and 'hover_focus'
  searchTermDisplay?: string | null; // For 'poi_no_match' (name of the POI searched)
}

// Default coordinates centered on US (fallback if no location is available)
const DEFAULT_CENTER: [number, number] = [-98.5795, 39.8283]; // Center of US
const DEFAULT_ZOOM = ZOOM_LEVELS.COUNTRY;

// Define the API response structure (consistent with api/hotels/route.ts)
interface HotelsApiResponse {
  hotels: ClientHotel[];
  cityCenter?: [number, number];
  matchedHotel?: ClientHotel | null;
  matchConfidence?: number | null;
  cityBbox?: string | null; // Bbox used/generated by API for this search
  searchedPoinLocation?: { lat: number; lng: number; name: string } | null; // Ensure this matches API
}

function HotelSearchPageContent() {
  const [isPanelOpen, setIsPanelOpen] = useState(true);
  const [mapReady, setMapReady] = useState(false);
  const [initialPaddingSet, setInitialPaddingSet] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  
  const [activeFilters, setActiveFilters] = useState<Filters>({
    inRoom: false,
    inGym: false,
    loyaltyPrograms: [],
  });
  
  const { searchContextState, handleLocationRetrieved: handleLocationRetrievedFromContext } = useSearch();
  const { currentIntent, needsFreshHotels } = searchContextState;

  // Selected hotel for the modal (distinct from selectedHotelNameForQuery in intent)
  const [selectedHotelForModal, setSelectedHotelForModal] = useState<ClientHotel | null>(null);

  // New consolidated mapFocusState to replace several separate state variables
  const [mapFocusState, setMapFocusState] = useState<MapFocusState>({
    type: 'idle',
    centerCoordinates: DEFAULT_CENTER,
    zoomLevel: DEFAULT_ZOOM
  });

  const mapRef = useRef<MapboxMapType | null>(null);

  const [isMobile, setIsMobile] = useState(false);
  const bottomSheetRef = useRef<BottomSheetHandle | null>(null);

  const { uiState, setActiveHotel, clearActiveHotel } = useUIInteraction();

  const [userSetZoomLevel, setUserSetZoomLevel] = useState<number | null>(null);

  // State for "Search this area" button
  const [showSearchAreaButton, setShowSearchAreaButton] = useState(false);
  const [lastSearchedMapBounds, setLastSearchedMapBounds] = useState<string | null>(null);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const { 
    data: apiResponse, 
    isLoading,
    isFetching,
    isPlaceholderData,
    isError: isFetchError, 
    error: fetchError,
    isSuccess: isFetchSuccess,
  } = useQuery<HotelsApiResponse, Error>({
    queryKey: [
      'hotels',
      currentIntent.location?.lat,
      currentIntent.location?.lng,
      currentIntent.searchType,
      currentIntent.selectedHotelNameForQuery, // Part of key if it's a hotel search
      // needsFreshHotels // Consider if this is still needed or if queryKey changes suffice
    ],
    queryFn: async () => {
      if (!currentIntent.location) return { hotels: [], cityBbox: null }; // Default empty response
      
      const { lat, lng } = currentIntent.location;
      let apiUrl = `/api/hotels?lat=${lat}&lng=${lng}`;
      
      if (currentIntent.searchTerm) {
        apiUrl += `&searchTerm=${encodeURIComponent(currentIntent.searchTerm)}`;
      }
      
      if (currentIntent.searchType) {
        apiUrl += `&featureType=${encodeURIComponent(currentIntent.searchType === 'hotel' ? 'poi' : 'place')}`;
      }
      
      if (currentIntent.searchType === 'hotel' && currentIntent.selectedHotelNameForQuery) {
        apiUrl += `&freeText=${encodeURIComponent(currentIntent.selectedHotelNameForQuery)}`;
      }
      
      // Use the API-provided bbox from PREVIOUS call if available and not a "fresh" request for this intent
      if (lastSearchedMapBounds && !needsFreshHotels) {
        // Now using lastSearchedMapBounds (simple string format) if not a fresh search
        apiUrl += `&cityBbox=${encodeURIComponent(lastSearchedMapBounds)}`;
      } else if (currentIntent.mapboxFeatureBbox && !needsFreshHotels) {
        // If it's not a fresh search and no lastSearchedMapBounds, but current intent has mapbox one (e.g. first city search)
        apiUrl += `&cityBbox=${encodeURIComponent(currentIntent.mapboxFeatureBbox)}`;
      }

      console.log('[HotelsQuery] fetching', { 
        apiUrl,
        isHotelSearchQuery: currentIntent.searchType === 'hotel',
        reusingApiBbox: !!(lastSearchedMapBounds && !needsFreshHotels),
        reusingMapboxBbox: !!(currentIntent.mapboxFeatureBbox && !needsFreshHotels && !lastSearchedMapBounds)
      });

      const response = await fetch(apiUrl);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: "Unknown error fetching hotels" }));
        throw new Error(errorData.message || `Error: ${response.status}`);
      }
      const data: HotelsApiResponse = await response.json(); 

      console.log('[HotelsQuery] response', { 
        hotelsCount: data.hotels.length, 
        matchedHotelId: data.matchedHotel?.id, 
        matchConfidence: data.matchConfidence,
        hasCityBbox: !!data.cityBbox
      });
      
      return data;
    },
    enabled: !!currentIntent.location, // Only run query if a location is part of the intent
    retry: 1,
    placeholderData: keepPreviousData, // Use TanStack Query's keepPreviousData
    staleTime: 5 * 60 * 1000, // Keep data fresh for 5 minutes
  });

  // Derive the loading state for skeletons
  // Show skeletons if:
  // 1. It's the initial load for this query key (isLoading)
  // 2. It's fetching a new query's data but showing old data as placeholder (isFetching && isPlaceholderData)
  const showSkeletons = isLoading || (isFetching && isPlaceholderData);
  
  // Extracted data from apiResponse for consumption by UI
  const hotelsFromApi = useMemo(() => apiResponse?.hotels || [], [apiResponse]);
  const matchedHotelFromApi = useMemo(() => apiResponse?.matchedHotel, [apiResponse]);

  // Wrapper function to reset zoom on *any* new location retrieval from search input
  const handleNewSearchLocation = useCallback((feature: MapboxGeocodingFeature) => {
    handleLocationRetrievedFromContext(feature);
    setUserSetZoomLevel(null); // Explicitly reset user zoom
    setShowSearchAreaButton(false); // Hide button on new search
    if (feature.mapboxBbox && feature.mapboxBbox.length > 0) {
      setLastSearchedMapBounds(feature.mapboxBbox.join(',')); // Join array to string
    } else {
      // If no bbox from feature, nullify. API response will set it if available.
      setLastSearchedMapBounds(null); 
    }
  }, [handleLocationRetrievedFromContext]);

  // Callback for MapboxMap to report user-initiated zoom
  const handleUserZoomChange = useCallback((zoom: number) => {
    setUserSetZoomLevel(zoom);
  }, []);

  // Handle successful API response: update apiProvidedCityBbox and mapFocusState
  useEffect(() => {
    if (isFetchSuccess && apiResponse) {
      let processedApiCityBboxForLastSearched: string | null = null;

      if (apiResponse.cityBbox) {
        // Attempt to process apiResponse.cityBbox into "swLng,swLat,neLng,neLat" for lastSearchedMapBounds
        if (typeof apiResponse.cityBbox === 'string') {
          if (apiResponse.cityBbox.includes('{') && apiResponse.cityBbox.includes('coords')) {
            try {
              const parsedBbox = JSON.parse(apiResponse.cityBbox);
              // Assuming coords is [[sw_lng, sw_lat], [nw_lng, nw_lat], [ne_lng, ne_lat], [se_lng, se_lat]]
              // We need sw (coords[0]) and ne (coords[2])
              if (parsedBbox.coords && Array.isArray(parsedBbox.coords) && parsedBbox.coords.length >= 3 && 
                  Array.isArray(parsedBbox.coords[0]) && parsedBbox.coords[0].length === 2 &&
                  Array.isArray(parsedBbox.coords[2]) && parsedBbox.coords[2].length === 2) {
                const sw = parsedBbox.coords[0]; // [lat, lng]
                const ne = parsedBbox.coords[2]; // [lat, lng]
                // Construct the string as "swLng,swLat,neLng,neLat"
                processedApiCityBboxForLastSearched = `${sw[1]},${sw[0]},${ne[1]},${ne[0]}`;
              } else {
                console.warn("[Search this area] API cityBbox was JSON but had an unexpected structure:", apiResponse.cityBbox);
              }
            } catch (e) {
              console.warn("[Search this area] Failed to parse API cityBbox as JSON:", apiResponse.cityBbox, e);
            }
          } else {
            // Does not look like JSON, try to validate if it's a simple "lng,lat,lng,lat" string
            const parts = apiResponse.cityBbox.split(',');
            if (parts.length === 4 && parts.every(part => !isNaN(parseFloat(part)))) {
              processedApiCityBboxForLastSearched = apiResponse.cityBbox;
            } else {
              console.warn("[Search this area] API cityBbox was not JSON and not a valid simple bbox string:", apiResponse.cityBbox);
            }
          }
        } else {
          console.warn("[Search this area] API cityBbox was not a string:", apiResponse.cityBbox);
        }
      }

      // Set lastSearchedMapBounds based on processed API bbox or intent's bbox
      if (processedApiCityBboxForLastSearched) {
        setLastSearchedMapBounds(processedApiCityBboxForLastSearched);
      } else if (!apiResponse.cityBbox && currentIntent.mapboxFeatureBbox && needsFreshHotels) {
        // Fallback to intent's bbox if API provided no bbox at all, AND this is a fresh search triggered by intent
        setLastSearchedMapBounds(currentIntent.mapboxFeatureBbox);
      } else if (apiResponse.cityBbox && !processedApiCityBboxForLastSearched) {
        // API provided a cityBbox, but we couldn't process it into the simple format.
        // Set to null to prevent errors in handleMoveEnd.
        console.warn(`[Search this area] API cityBbox ('${apiResponse.cityBbox}') was unusable for lastSearchedMapBounds. Setting to null.`);
        setLastSearchedMapBounds(null);
      }
      // If apiResponse.cityBbox was null/undefined, and the 'else if' for currentIntent didn't match,
      // lastSearchedMapBounds is NOT updated by this block, retaining its previous value (e.g. from a filter change).

      setShowSearchAreaButton(false); // Hide button after a successful search (or if bounds are now null)

      // Update mapFocusState based on API response
      // Check if the current search was initiated by the 'Search this area' button
      const isMapDragSearch = currentIntent.rawMapboxFeature?.category === 'map_drag_search';

      if (currentIntent.searchType === 'hotel') {
        if (apiResponse.matchedHotel && apiResponse.matchedHotel.id) {
          setMapFocusState({
            type: 'match_found',
            centerCoordinates: [apiResponse.matchedHotel.lng, apiResponse.matchedHotel.lat],
            zoomLevel: userSetZoomLevel ?? ZOOM_LEVELS.HOTEL,
            focusedHotelId: apiResponse.matchedHotel.id
          });
          setActiveHotel(apiResponse.matchedHotel.id, 'initial_match');
        } else if (apiResponse.searchedPoinLocation) {
          setMapFocusState({
            type: 'poi_no_match',
            centerCoordinates: [apiResponse.searchedPoinLocation.lng, apiResponse.searchedPoinLocation.lat],
            zoomLevel: userSetZoomLevel ?? ZOOM_LEVELS.NO_MATCH_CITY_OVERVIEW,
            searchTermDisplay: apiResponse.searchedPoinLocation.name
          });
          clearActiveHotel();
        } else {
          if (currentIntent.location && currentIntent.searchTerm) {
            setMapFocusState({
              type: 'poi_no_match',
              centerCoordinates: [currentIntent.location.lng, currentIntent.location.lat],
              zoomLevel: userSetZoomLevel ?? ZOOM_LEVELS.NO_MATCH_CITY_OVERVIEW,
              searchTermDisplay: currentIntent.searchTerm
            });
            clearActiveHotel();
          }
        }
      } else { // City Search (or map_drag_search which we treat like a city search here)
        setMapFocusState({
          type: 'city_overview',
          // Use the intent's location if it was a map drag search, otherwise use API center
          centerCoordinates: isMapDragSearch && currentIntent.location 
            ? [currentIntent.location.lng, currentIntent.location.lat]
            : apiResponse.cityCenter || DEFAULT_CENTER,
          zoomLevel: userSetZoomLevel ?? ZOOM_LEVELS.CITY, // Use user's zoom if set
          focusedHotelId: null, // Ensure focus is cleared
          searchTermDisplay: null
        });
        clearActiveHotel(); // Ensure no hotel is highlighted from previous state
      }
    } else if (isFetchError && fetchError) {
      console.error("Failed to fetch hotels:", fetchError.message);
      // hotelsFromApi will be an empty array due to its memoized default.
    }
  }, [isFetchSuccess, apiResponse, isFetchError, fetchError, currentIntent, setActiveHotel, clearActiveHotel, userSetZoomLevel, needsFreshHotels]);

  // Reset states when the core search location in the intent changes significantly
  useEffect(() => {
    // Only reset map focus/zoom if it's a new search *not* triggered by 'Search this area'
    if (needsFreshHotels && currentIntent.rawMapboxFeature?.category !== 'map_drag_search') { 
      setUserSetZoomLevel(null); // Reset user zoom on new significant search
      setMapFocusState({
        type: 'idle',
        centerCoordinates: currentIntent.location ? 
          [currentIntent.location.lng, currentIntent.location.lat] : 
          DEFAULT_CENTER,
        zoomLevel: ZOOM_LEVELS.COUNTRY // Start with a default or country zoom
      });
    }
    if (currentIntent.location) {
      setSelectedHotelForModal(null);
      // If it's a new search, reset user zoom so app defaults can take over
      if (needsFreshHotels) setUserSetZoomLevel(null);
    }
  }, [currentIntent.location, needsFreshHotels, currentIntent.rawMapboxFeature?.category]);

  const displayedHotels = useMemo(() => {
    // If showing skeletons, return empty array immediately to prevent rendering stale cards
    if (showSkeletons) {
      return [];
    }
    // Start with all hotels and apply active filters
    let filtered = [...hotelsFromApi];
    if (activeFilters.loyaltyPrograms.length > 0) {
      filtered = filtered.filter(hotel => {
        return activeFilters.loyaltyPrograms.some(filterProgram => {
          if (filterProgram === "Other") return hotel.loyaltyProgram === "Other";
          if (PRIMARY_LOYALTY_PROGRAMS.includes(filterProgram)) return hotel.loyaltyProgram === filterProgram;
          return hotel.brand === filterProgram && (hotel.loyaltyProgram === "Other" || hotel.loyaltyProgram === hotel.brand);
        });
      });
    }
    if (activeFilters.inRoom) filtered = filtered.filter(hotel => hotel.in_room);
    if (activeFilters.inGym) filtered = filtered.filter(hotel => hotel.in_gym);

    // Sort after filtering
    filtered.sort((a, b) => {
      if (a.in_room !== b.in_room) return a.in_room ? -1 : 1;
      if (a.in_gym !== b.in_gym) return a.in_gym ? -1 : 1;
      if (a.distance_m === null) return 1;
      if (b.distance_m === null) return -1;
      return a.distance_m - b.distance_m;
    });

    // If a specific hotel search matched, bring the matched hotel to the front of the filtered list
    const isHotelSearchIntent = currentIntent.searchType === 'hotel';
    const matchedHotelId = matchedHotelFromApi?.id;
    if (isHotelSearchIntent && matchedHotelId) {
      const idx = filtered.findIndex(h => h.id === matchedHotelId);
      if (idx > -1) {
        const [matched] = filtered.splice(idx, 1);
        return [matched, ...filtered];
      }
    }
    return filtered;
  }, [hotelsFromApi, activeFilters, currentIntent.searchType, matchedHotelFromApi, showSkeletons]);

  // Unified hover processing for both map and sidebar
  const processHotelHover = useCallback((id: number | null, source: 'sidebar' | 'map', coords?: { lng: number; lat: number }) => {
    if (id !== null) {
      setActiveHotel(id, source === 'map' ? 'map_hover' : 'sidebar_hover');
      if (source === 'sidebar' && coords) {
        setMapFocusState(prev => ({
          ...prev,
          type: 'hover_focus',
          focusedHotelId: id,
          centerCoordinates: [coords.lng, coords.lat],
          zoomLevel: ZOOM_LEVELS.HOTEL
        }));
      }
    } else {
      clearActiveHotel();
    }
  }, [setActiveHotel, clearActiveHotel]);

  const handleMapMarkerHover = useCallback((id: number | null, hotelCoords?: { lng: number; lat: number }) => {
    if (isMobile && id === null) return;
    processHotelHover(id, 'map', hotelCoords);
  }, [isMobile, processHotelHover]);

  const handleMapLoad = useCallback(() => setMapReady(true), []);
  const handleCloseModal = useCallback(() => setSelectedHotelForModal(null), []);

  const handleHotelSelect = useCallback((hotel: ClientHotel, source: 'list' | 'map' = 'list') => {
    if (isMobile) {
      if (source === 'list') { // Tap from BottomSheet or other list components
        // First update map focus state directly to ensure it stays focused
        setMapFocusState({
          type: 'match_found', // Using match_found to ensure consistent behavior
          centerCoordinates: [hotel.lng, hotel.lat],
          zoomLevel: ZOOM_LEVELS.HOTEL,
          focusedHotelId: hotel.id
        });
        
        // Explicitly set active hotel ID for mobile list selection
        setActiveHotel(hotel.id, 'sidebar_hover');
        
        // Then handle location retrieval (which may trigger other state changes)
        handleLocationRetrievedFromContext({
          lat: hotel.lat,
          lng: hotel.lng,
          placeName: hotel.name,
          hotelName: hotel.name,
          mapboxBbox: undefined,
          featureType: 'poi',
          category: '',
        });
        
        bottomSheetRef.current?.snapToState('peek');
        
        // Ensure active hotel state persists after location change
        setTimeout(() => {
          setActiveHotel(hotel.id, 'sidebar_hover');
        }, 100);
      } else { // source === 'map' (Tap on map marker)
        if (hotel.id === uiState.activeHotelId) { // Tapped the currently focused/selected or API matched hotel marker
          setSelectedHotelForModal(hotel);
          bottomSheetRef.current?.snapToState('closed'); // Close sheet to give modal focus
        } else { // Tapped a *different* marker on the map
          handleLocationRetrievedFromContext({
            lat: hotel.lat,
            lng: hotel.lng,
            placeName: hotel.name,
            hotelName: hotel.name,
            mapboxBbox: undefined,
            featureType: 'poi',
            category: '',
          });
          bottomSheetRef.current?.snapToState('peek');
        }
      }
    } else {
      // Desktop behavior: open modal
      setSelectedHotelForModal(hotel);
    }
  }, [isMobile, handleLocationRetrievedFromContext, bottomSheetRef, uiState.activeHotelId, setActiveHotel, setMapFocusState]);

  useEffect(() => {
    if (mapRef.current && mapReady && !initialPaddingSet) {
      let PADDING_BOTTOM = 0;
      if (isMobile) {
        if (isPanelOpen) { 
          const peekVh = 25;
          PADDING_BOTTOM = (peekVh * window.innerHeight) / 100;
        }
      }
      // Calculate sidebar width based on window width
      const sidebarWidthPx = (window.innerWidth * DESKTOP_SIDEBAR_WIDTH_PERCENTAGE) / 100;
      const basePadding = {
        left: !isMobile && isPanelOpen ? sidebarWidthPx : 0,
        right: 0,
        top: isMobile ? MOBILE_SEARCH_BAR_HEIGHT : 0
      };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: PADDING_BOTTOM }, duration: 0 });
      setInitialPaddingSet(true);
      setTimeout(() => mapRef.current?.resize(), 50); 
    }
  }, [mapReady, isPanelOpen, initialPaddingSet, isMobile]);

  useEffect(() => {
    if (mapRef.current && mapReady) {
      setTimeout(() => mapRef.current?.resize(), 100); 
    }
  }, [isMobile, mapReady]);

  const handlePanelToggle = () => {
    const newIsOpen = !isPanelOpen;
    setIsPanelOpen(newIsOpen);
    if (isMobile) {
    } else {
      if (mapRef.current && mapReady) {
        // Calculate sidebar width based on window width
        const sidebarWidthPx = (window.innerWidth * DESKTOP_SIDEBAR_WIDTH_PERCENTAGE) / 100;
        const targetPaddingLeft = newIsOpen ? sidebarWidthPx : 0;
        const basePadding = { left: targetPaddingLeft, right: 0, top: 0 };
        mapRef.current.easeTo({ padding: { ...basePadding, bottom: 0 }, duration: 500, easing: cubicBezier(0.4, 0, 0.2, 1) });
        setTimeout(() => mapRef.current?.resize(), 550);
      }
    }
  };

  const handleBottomSheetStateChange = useCallback((newState: BottomSheetState, heightPx: number) => {
    if (mapRef.current && mapReady && isMobile) {
      const basePadding = { left: 0, right: 0, top: MOBILE_SEARCH_BAR_HEIGHT };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: heightPx }, duration: 300, easing: cubicBezier(0.4, 0, 0.2, 1) });
      setTimeout(() => mapRef.current?.resize(), 350); 
    }
    if (newState === 'closed' && isPanelOpen) setIsPanelOpen(false);
    if ((newState === 'peek' || newState === 'full') && !isPanelOpen ) setIsPanelOpen(true);
  }, [mapReady, isMobile, isPanelOpen]);

  // Effect to handle map centering on sidebar hover
  useEffect(() => {
    if (uiState.interactionSource === 'sidebar_hover' && uiState.activeHotelId !== null) {
      const activeHotel = displayedHotels.find(h => h.id === uiState.activeHotelId);
      if (activeHotel) {
        setMapFocusState(prev => ({
          ...prev,
          type: 'hover_focus',
          centerCoordinates: [activeHotel.lng, activeHotel.lat],
          zoomLevel: userSetZoomLevel ?? ZOOM_LEVELS.HOTEL, // Respect user zoom
          focusedHotelId: activeHotel.id
        }));
      }
    }
  }, [uiState.activeHotelId, uiState.interactionSource, displayedHotels, setMapFocusState, userSetZoomLevel]); // Added userSetZoomLevel

  // Scroll-to-view logic - ensure this only runs for map_hover or initial_match to avoid conflicts
  useEffect(() => {
    if (uiState.activeHotelId === null) return;
    // Only scroll if interaction came from map or was an initial match to prevent scroll fights with sidebar hover
    if (uiState.interactionSource === 'map_hover' || uiState.interactionSource === 'initial_match') {
        const scrollDelay = isMobile ? 300 : 50;
        setTimeout(() => {
          const hotelCard = document.querySelector(`[data-hotel-id="${uiState.activeHotelId}"]`);
          if (!hotelCard) return;
          const scrollContainer = isMobile 
            ? document.querySelector('.bottom-sheet-content')
            : document.querySelector('.overflow-y-auto');
          if (!scrollContainer) return;
          hotelCard.scrollIntoView({ behavior: 'smooth', block: isMobile ? 'start' : 'center' });
        }, scrollDelay);
    }
  }, [uiState.activeHotelId, uiState.interactionSource, isMobile]); // Added interactionSource

  const initialSheetStateForMobile = isPanelOpen ? 'peek' : 'closed';

  const currentCityNameForSearch = currentIntent.rawMapboxFeature?.placeName || currentIntent.searchTerm || '';

  const handleSearchThisArea = useCallback(() => {
    if (!mapRef.current) return;

    const currentZoom = mapRef.current.getZoom();
    setUserSetZoomLevel(currentZoom); // Set user zoom BEFORE context update

    const center = mapRef.current.getCenter();
    const currentBounds = mapRef.current.getBounds();
    if (!currentBounds) return; // Add null check

    const boundsArray = currentBounds.toArray(); 
    const flatBoundsArray = boundsArray.flat(); // This will be number[]
    const boundsString = flatBoundsArray.join(',');

    // Adding back the second argument now that SearchContext is updated
    handleLocationRetrievedFromContext({ 
      lat: center.lat,
      lng: center.lng,
      placeName: "Current map area", // Generic name for this type of search
      mapboxBbox: flatBoundsArray as [number, number, number, number], // Assert as tuple
      featureType: 'place', 
      category: 'map_drag_search', // Custom category for this interaction
      hotelName: undefined,
    }, true); // true indicates needsFreshHotels

    setShowSearchAreaButton(false);
    setLastSearchedMapBounds(boundsString); // Update bounds for the new search

  }, [handleLocationRetrievedFromContext, setUserSetZoomLevel, mapRef]);

  // Effect to detect map movement and show "Search this area" button
  useEffect(() => {
    const map = mapRef.current; // Capture map instance
    if (!mapReady || !map) { 
      setShowSearchAreaButton(false); // Ensure it's hidden if conditions not met
      return;
    }

    const handleMoveEnd = () => {
      if (isLoading || isFetching || showSkeletons || !lastSearchedMapBounds) {
        setShowSearchAreaButton(false);
        return;
      }
      
      // Don't show button if map is focused on a specific hotel match, hover, or POI no match
      if (mapFocusState.type === 'match_found' || mapFocusState.type === 'hover_focus' || mapFocusState.type === 'poi_no_match') {
          setShowSearchAreaButton(false);
          return;
      }

      try {
        const boundsParts = lastSearchedMapBounds.split(',').map(Number);
        if (boundsParts.length !== 4 || boundsParts.some(isNaN)) {
            console.warn("Invalid lastSearchedMapBounds format:", lastSearchedMapBounds);
            setShowSearchAreaButton(false);
            return;
        }
        const [swLng, swLat, neLng, neLat] = boundsParts;
        // Use LngLatBounds from mapbox-gl import
        const previousBounds = new LngLatBounds([swLng, swLat], [neLng, neLat]); 
        
        const currentMapCenter = map.getCenter();
        const currentMapBounds = map.getBounds(); // Get bounds for the check

        // Ensure currentMapBounds is not null before accessing methods
        if (!currentMapBounds) {
            setShowSearchAreaButton(false);
            return;
        }

        // Condition 1: View extends beyond previous bounds.
        const viewExceedsPrevious = !(previousBounds.contains(currentMapBounds.getSouthWest()) && previousBounds.contains(currentMapBounds.getNorthEast()));

        let centerMovedSignificantly = false;
        if (!viewExceedsPrevious) { // Only check center movement if view is still contained
            const previousCenter = previousBounds.getCenter();
            const currentViewportLngSpan = currentMapBounds.getEast() - currentMapBounds.getWest();
            const currentViewportLatSpan = currentMapBounds.getNorth() - currentMapBounds.getSouth();
            
            // Threshold: moved by 30% of current viewport's dimension
            const lngMoveThreshold = currentViewportLngSpan * 0.30;
            const latMoveThreshold = currentViewportLatSpan * 0.30;

            if (Math.abs(currentMapCenter.lng - previousCenter.lng) > lngMoveThreshold ||
                Math.abs(currentMapCenter.lat - previousCenter.lat) > latMoveThreshold) {
                centerMovedSignificantly = true;
            }
        }

        if (viewExceedsPrevious || centerMovedSignificantly) {
          setShowSearchAreaButton(true);
        } else {
          setShowSearchAreaButton(false); 
        }

      } catch (error) {
        console.error("Error processing map bounds for search area button:", error);
        setShowSearchAreaButton(false);
      }
    };

    map.on('moveend', handleMoveEnd);
    return () => {
      map.off('moveend', handleMoveEnd);
    };
  }, [mapReady, mapRef, isLoading, isFetching, showSkeletons, lastSearchedMapBounds, mapFocusState.type]);

  return (
    <div className="relative h-screen w-full overflow-hidden bg-gray-100">
      {isMobile && (
        <div className="fixed top-0 left-0 right-0 z-50 flex justify-center pt-4 px-4 pointer-events-none">
          <div className="w-full max-w-md pointer-events-auto flex items-center gap-2">
            <div className="flex-1">
              <CitySearchInput
                onLocationRetrieved={handleNewSearchLocation}
                onNoResultsFound={() => {}}
                isLoading={isFetching}
                className="bg-white p-3 rounded-xl shadow-xl w-full"
                initialValue={currentCityNameForSearch}
              />
            </div>
            <FilterPanel
              isMobile
              activeFilters={activeFilters}
              onFiltersChange={() => setShowFilters(true)}
            />
          </div>
        </div>
      )}

      {!isMobile && (
        <aside
          className={cn(
            "absolute z-20 border bg-background/95 backdrop-blur-sm",
            "shadow-[0_8px_30px_rgb(0,0,0,0.12)]",
            "transition-all duration-700 ease-in-out",
            "flex flex-col",
            "left-4 top-4 bottom-4 w-1/3 rounded-3xl",
            !isPanelOpen && "-translate-x-full"
          )}
        >
          <div className={cn(
            "p-6 flex items-center space-x-2",
            isPanelOpen && 'pr-14' 
          )}>
            <CitySearchInput
              onLocationRetrieved={handleNewSearchLocation}
              onNoResultsFound={() => {}}
              isLoading={isFetching}
              className="w-full" 
              initialValue={currentCityNameForSearch}
            />
          </div>
          <div className="flex-1 overflow-y-auto px-4 py-2">
            <HotelListPanel 
              hotels={displayedHotels}
              onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
              isMobile={isMobile}
              activeFilters={activeFilters}
              onFiltersChange={setActiveFilters}
              onMobileFilterButtonClick={() => {}}
              hasSearched={!!currentIntent.location}
              showSkeletons={showSkeletons}
            />
          </div>

          <Button
            variant="secondary"
            size="icon"
            className={cn(
              "absolute top-2 left-[100%] ml-[5px]",
              "z-30 h-10 w-10 rounded-full",
              "bg-background/95 shadow-lg backdrop-blur-sm hover:bg-background/80",
              "transition-all duration-500 ease-out"
            )}
            onClick={handlePanelToggle}
            disabled={!mapReady}
          >
            <ChevronLeft
              className="h-4 w-4 transition-transform duration-500 ease-out"
              style={{ transform: isPanelOpen ? 'rotate(0deg)' : 'rotate(180deg)' }}
            />
          </Button>
        </aside>
      )}

      {isMobile && (
        <BottomSheet 
          ref={bottomSheetRef}
          hotels={displayedHotels}
          initialState={initialSheetStateForMobile}
          onStateChange={handleBottomSheetStateChange}
          onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
          hasSearched={!!currentIntent.location}
          hasActiveFilters={activeFilters.inRoom || activeFilters.inGym || activeFilters.loyaltyPrograms.length > 0}
          onClearFilters={() => setActiveFilters({ inRoom: false, inGym: false, loyaltyPrograms: [] })}
          showSkeletons={showSkeletons}
        />
      )}

      <div className={cn(
        "absolute inset-0 z-10",
        isMobile ? `top-[${MOBILE_SEARCH_BAR_HEIGHT}px]` : "top-0"
      )}>
        <MapboxMap 
          hotels={displayedHotels}
          externalMapRef={mapRef} 
          onMarkerClick={(hotel) => handleHotelSelect(hotel, 'map')}
          onMapLoad={handleMapLoad}
          isMobile={isMobile}
          onMarkerHover={handleMapMarkerHover}
          mapReady={mapReady}
          onUserZoom={handleUserZoomChange}
          mapFocusProps={{
            center: mapFocusState.centerCoordinates,
            zoom: mapFocusState.zoomLevel,
            highlightType: mapFocusState.type,
            highlightHotelId: uiState.activeHotelId,
            noMatchSearchTerm: mapFocusState.searchTermDisplay
          }}
        />
      </div>

      {selectedHotelForModal && (
        <HotelDetailModal 
          hotel={selectedHotelForModal} 
          onClose={handleCloseModal} 
        />
      )}

      {/* Mobile Filter Modal */}
      {isMobile && (
        <FilterModal
          isOpen={showFilters}
          onClose={() => setShowFilters(false)}
          activeFilters={activeFilters}
          onApplyFilters={(newFilters) => {
            setActiveFilters(newFilters);
            setShowFilters(false);
          }}
        />
      )}

      {/* "Search this area" Button - Render on mobile and desktop */}
      {showSearchAreaButton && (
        <div className={cn(
          "absolute z-30 pointer-events-auto",
          isMobile ? "top-[15vh]" : "top-[2vh]", // Adjust top for mobile search bar (60px + 16px padding)
          // Center within map area (right 2/3 if panel open, full width if closed or mobile)
          isPanelOpen && !isMobile ? "left-[66.66%] -translate-x-1/2" : "left-1/2 -translate-x-1/2"
        )}>
          <Button
            onClick={handleSearchThisArea}
            variant="secondary"
            className="bg-background/95 hover:bg-background/80 text-foreground font-semibold py-2 px-4 border border-border rounded-full shadow-xl backdrop-blur-sm"
            disabled={isLoading || isFetching}
          >
            Search this area
          </Button>
        </div>
      )}
    </div>
  );
}

export default function HotelSearchPage() {
  return (
    <UIInteractionProvider>
      <SearchProvider>
        <HotelSearchPageContent />
      </SearchProvider>
    </UIInteractionProvider>
  );
}
