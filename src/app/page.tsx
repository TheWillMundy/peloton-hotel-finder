"use client";

// React and Next.js imports
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';

// Third-party library imports
import { ChevronLeft } from 'lucide-react';
import type { Map as MapboxMapType } from 'mapbox-gl';
import { useQuery } from '@tanstack/react-query';

// Context imports
import { SearchProvider, useSearch, ZOOM_LEVELS } from '@/app/contexts/SearchContext';
import { UIInteractionProvider, useUIInteraction } from '@/app/contexts/UIInteractionContext';

// UI component imports
import { Button } from '@/app/components/ui/button';
import BottomSheet from '@/app/components/ui/BottomSheet';
import type { BottomSheetHandle, BottomSheetState } from '@/app/components/ui/BottomSheet';

// Map component imports
import MapboxMap from '@/app/components/map/MapboxMap';

// Hotel component imports
import HotelDetailModal from '@/app/components/hotel/HotelDetailModal';
import HotelListPanel from '@/app/components/hotel/HotelListPanel';

// Filter component imports
import FilterPanel from '@/app/components/filter/FilterPanel';
import FilterModal from '@/app/components/filter/FilterModal';
import type { Filters } from '@/app/components/filter/FilterChips';

// Type imports
import type { ClientHotel } from '@/lib/pelotonAPI';

// Utility imports
import { cn, cubicBezier } from '@/lib/utils';

// Dynamically imported components
const CitySearchInput = dynamic(() => import('@/app/components/search/CitySearchInput'), { ssr: false });

// Define primary loyalty programs, could also be imported from FilterChips if kept there
const PRIMARY_LOYALTY_PROGRAMS = [
  "Accor Le Club", "Best Western Rewards", "Choice Privileges", "Hilton Honors", 
  "IHG Rewards Club", "Marriott Bonvoy", "Radisson Rewards", "World of Hyatt", "Wyndham Rewards"
];

const MOBILE_BREAKPOINT = 768;
const DESKTOP_SIDEBAR_WIDTH_PERCENTAGE = 33.33; // Changed from fixed 420px to percentage
const MOBILE_SEARCH_BAR_HEIGHT = 60; // Approximate height for the search bar on mobile

// New Interface for unified map focus state management
interface MapFocusState {
  type: 'idle' | 'city_overview' | 'match_found' | 'poi_no_match' | 'hover_focus';
  centerCoordinates: [number, number]; // lng, lat
  zoomLevel: number;
  focusedHotelId?: number | null; // For 'match_found' and 'hover_focus'
  searchTermDisplay?: string | null; // For 'poi_no_match' (name of the POI searched)
}

// Default coordinates centered on US (fallback if no location is available)
const DEFAULT_CENTER: [number, number] = [-98.5795, 39.8283]; // Center of US
const DEFAULT_ZOOM = ZOOM_LEVELS.COUNTRY;

// Define the API response structure (consistent with api/hotels/route.ts)
interface HotelsApiResponse {
  hotels: ClientHotel[];
  cityCenter?: [number, number];
  matchedHotel?: ClientHotel | null;
  matchConfidence?: number | null;
  cityBbox?: string | null; // Bbox used/generated by API for this search
  searchedPoinLocation?: { lat: number; lng: number; name: string } | null; // Ensure this matches API
}

function HotelSearchPageContent() {
  const [isPanelOpen, setIsPanelOpen] = useState(true);
  const [mapReady, setMapReady] = useState(false);
  const [initialPaddingSet, setInitialPaddingSet] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  
  const [activeFilters, setActiveFilters] = useState<Filters>({
    inRoom: false,
    inGym: false,
    loyaltyPrograms: [],
  });
  
  const { searchContextState, handleLocationRetrieved } = useSearch();
  const { currentIntent, needsFreshHotels } = searchContextState;

  // Local state for the cityBbox returned by the API, for potential reuse
  const [apiProvidedCityBbox, setApiProvidedCityBbox] = useState<string | null>(null);
  // Selected hotel for the modal (distinct from selectedHotelNameForQuery in intent)
  const [selectedHotelForModal, setSelectedHotelForModal] = useState<ClientHotel | null>(null);

  // New consolidated mapFocusState to replace several separate state variables
  const [mapFocusState, setMapFocusState] = useState<MapFocusState>({
    type: 'idle',
    centerCoordinates: DEFAULT_CENTER,
    zoomLevel: DEFAULT_ZOOM
  });

  const mapRef = useRef<MapboxMapType | null>(null);

  const [isMobile, setIsMobile] = useState(false);
  const [currentBottomSheetState, setCurrentBottomSheetState] = useState<BottomSheetState>('closed');
  const bottomSheetRef = useRef<BottomSheetHandle | null>(null);

  const { uiState, setActiveHotel, clearActiveHotel } = useUIInteraction();

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const { 
    data: apiResponse, 
    isLoading: isLoadingHotels, 
    isError: isFetchError, 
    error: fetchError,
    isSuccess: isFetchSuccess,
  } = useQuery<HotelsApiResponse, Error>({
    queryKey: [
      'hotels',
      currentIntent.location?.lat,
      currentIntent.location?.lng,
      currentIntent.searchType,
      currentIntent.selectedHotelNameForQuery, // Part of key if it's a hotel search
      needsFreshHotels // Important for cache busting/API cache behavior
    ],
    queryFn: async () => {
      if (!currentIntent.location) return { hotels: [], cityBbox: null }; // Default empty response
      
      const { lat, lng } = currentIntent.location;
      let apiUrl = `/api/hotels?lat=${lat}&lng=${lng}`;
      
      if (currentIntent.searchTerm) {
        apiUrl += `&searchTerm=${encodeURIComponent(currentIntent.searchTerm)}`;
      }
      
      if (currentIntent.searchType) {
        apiUrl += `&featureType=${encodeURIComponent(currentIntent.searchType === 'hotel' ? 'poi' : 'place')}`;
      }
      
      if (currentIntent.searchType === 'hotel' && currentIntent.selectedHotelNameForQuery) {
        apiUrl += `&freeText=${encodeURIComponent(currentIntent.selectedHotelNameForQuery)}`;
      }
      
      // Use the API-provided bbox from PREVIOUS call if available and not a "fresh" request for this intent
      if (apiProvidedCityBbox && !needsFreshHotels) {
        apiUrl += `&cityBbox=${encodeURIComponent(apiProvidedCityBbox)}`;
      } else if (currentIntent.mapboxFeatureBbox && !needsFreshHotels) {
        // If it's not a fresh search and no apiProvidedCityBbox, but current intent has mapbox one (e.g. first city search)
        apiUrl += `&cityBbox=${encodeURIComponent(currentIntent.mapboxFeatureBbox)}`;
      }

      console.log('[HotelsQuery] fetching', { 
        apiUrl,
        isHotelSearchQuery: currentIntent.searchType === 'hotel',
        reusingApiBbox: !!(apiProvidedCityBbox && !needsFreshHotels),
        reusingMapboxBbox: !!(currentIntent.mapboxFeatureBbox && !needsFreshHotels && !apiProvidedCityBbox)
      });

      const response = await fetch(apiUrl);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: "Unknown error fetching hotels" }));
        throw new Error(errorData.message || `Error: ${response.status}`);
      }
      const data: HotelsApiResponse = await response.json(); 

      console.log('[HotelsQuery] response', { 
        hotelsCount: data.hotels.length, 
        matchedHotelId: data.matchedHotel?.id, 
        matchConfidence: data.matchConfidence,
        hasCityBbox: !!data.cityBbox
      });
      
      return data;
    },
    enabled: !!currentIntent.location, // Only run query if a location is part of the intent
    retry: 1,
    placeholderData: (previousData) => previousData, // Keep previous data while loading new
  });

  // Extracted data from apiResponse for consumption by UI
  const hotelsFromApi = useMemo(() => apiResponse?.hotels || [], [apiResponse]);
  const matchedHotelFromApi = useMemo(() => apiResponse?.matchedHotel, [apiResponse]);

  // Handle successful API response: update apiProvidedCityBbox and mapFocusState
  useEffect(() => {
    if (isFetchSuccess && apiResponse) {
      if (apiResponse.cityBbox) {
        setApiProvidedCityBbox(apiResponse.cityBbox);
      }

      // Update mapFocusState based on API response
      if (currentIntent.searchType === 'hotel') {
        if (apiResponse.matchedHotel && apiResponse.matchedHotel.id) {
          // Hotel Match Found - update mapFocusState to focus on matched hotel
          setMapFocusState({
            type: 'match_found',
            centerCoordinates: [apiResponse.matchedHotel.lng, apiResponse.matchedHotel.lat],
            zoomLevel: ZOOM_LEVELS.HOTEL,
            focusedHotelId: apiResponse.matchedHotel.id
          });
          setActiveHotel(apiResponse.matchedHotel.id, 'initial_match');
        } else if (apiResponse.searchedPoinLocation) {
          // POI Searched, No Peloton Match Found - update mapFocusState for "no match" display
          setMapFocusState({
            type: 'poi_no_match',
            centerCoordinates: [apiResponse.searchedPoinLocation.lng, apiResponse.searchedPoinLocation.lat],
            zoomLevel: ZOOM_LEVELS.NO_MATCH_CITY_OVERVIEW,
            searchTermDisplay: apiResponse.searchedPoinLocation.name
          });
          clearActiveHotel();
        } else {
          // No Hotel Match Found for a specific hotel search, and no specific POI info returned by API
          if (currentIntent.location && currentIntent.searchTerm) {
            setMapFocusState({
              type: 'poi_no_match',
              centerCoordinates: [currentIntent.location.lng, currentIntent.location.lat],
              zoomLevel: ZOOM_LEVELS.NO_MATCH_CITY_OVERVIEW,
              searchTermDisplay: currentIntent.searchTerm
            });
            clearActiveHotel();
          }
        }
      } else {
        // City Search (not a specific hotel search)
        // Update mapFocusState to show city overview
        setMapFocusState({
          type: 'city_overview',
          centerCoordinates: apiResponse.cityCenter || DEFAULT_CENTER,
          zoomLevel: ZOOM_LEVELS.CITY
        });
        clearActiveHotel();
      }

    } else if (isFetchError && fetchError) {
      console.error("Failed to fetch hotels:", fetchError.message);
      // hotelsFromApi will be an empty array due to its memoized default.
    }
  }, [isFetchSuccess, apiResponse, isFetchError, fetchError, currentIntent.searchType, currentIntent.location, currentIntent.searchTerm, isMobile, currentBottomSheetState, setActiveHotel, clearActiveHotel]);

  // Reset states when the core search location in the intent changes significantly
  useEffect(() => {
    if (needsFreshHotels) { // This flag is set in SearchContext when location changes significantly
        setApiProvidedCityBbox(null); // Clear any bbox from a previous city
        setActiveFilters({ inRoom: false, inGym: false, loyaltyPrograms: [] });
        setShowFilters(false);
        setSelectedHotelForModal(null); // Clear modal for any new search
        
        // Reset map focus to idle (will be updated once API response comes in)
        setMapFocusState({
          type: 'idle',
          centerCoordinates: currentIntent.location ? 
            [currentIntent.location.lng, currentIntent.location.lat] : 
            DEFAULT_CENTER,
          zoomLevel: DEFAULT_ZOOM
        });
    }
    // When a new location is set (even if not "fresh"), always clear the modal
    // to avoid showing details from a previous search context.
    if (currentIntent.location) {
      setSelectedHotelForModal(null);
    }

  }, [currentIntent.location, needsFreshHotels]);

  const displayedHotels = useMemo(() => {
    // Start with all hotels and apply active filters
    let filtered = [...hotelsFromApi];
    if (activeFilters.loyaltyPrograms.length > 0) {
      filtered = filtered.filter(hotel => {
        return activeFilters.loyaltyPrograms.some(filterProgram => {
          if (filterProgram === "Other") return hotel.loyaltyProgram === "Other";
          if (PRIMARY_LOYALTY_PROGRAMS.includes(filterProgram)) return hotel.loyaltyProgram === filterProgram;
          return hotel.brand === filterProgram && (hotel.loyaltyProgram === "Other" || hotel.loyaltyProgram === hotel.brand);
        });
      });
    }
    if (activeFilters.inRoom) filtered = filtered.filter(hotel => hotel.in_room);
    if (activeFilters.inGym) filtered = filtered.filter(hotel => hotel.in_gym);

    // Sort after filtering
    filtered.sort((a, b) => {
      if (a.in_room !== b.in_room) return a.in_room ? -1 : 1;
      if (a.in_gym !== b.in_gym) return a.in_gym ? -1 : 1;
      if (a.distance_m === null) return 1;
      if (b.distance_m === null) return -1;
      return a.distance_m - b.distance_m;
    });

    // If a specific hotel search matched, bring the matched hotel to the front of the filtered list
    const isHotelSearchIntent = currentIntent.searchType === 'hotel';
    const matchedHotelId = matchedHotelFromApi?.id;
    if (isHotelSearchIntent && matchedHotelId) {
      const idx = filtered.findIndex(h => h.id === matchedHotelId);
      if (idx > -1) {
        const [matched] = filtered.splice(idx, 1);
        return [matched, ...filtered];
      }
    }
    return filtered;
  }, [hotelsFromApi, activeFilters, currentIntent.searchType, matchedHotelFromApi]);

  // Unified hover processing for both map and sidebar
  const processHotelHover = useCallback((id: number | null, source: 'sidebar' | 'map', coords?: { lng: number; lat: number }) => {
    if (id !== null) {
      setActiveHotel(id, source === 'map' ? 'map_hover' : 'sidebar_hover');
      if (source === 'sidebar' && coords) {
        setMapFocusState(prev => ({
          ...prev,
          type: 'hover_focus',
          focusedHotelId: id,
          centerCoordinates: [coords.lng, coords.lat],
          zoomLevel: prev.zoomLevel
        }));
      }
    } else {
      clearActiveHotel();
    }
  }, [setActiveHotel, clearActiveHotel]);

  const handleMapMarkerHover = useCallback((id: number | null, hotelCoords?: { lng: number; lat: number }) => {
    if (isMobile && id === null) return;
    processHotelHover(id, 'map', hotelCoords);
  }, [isMobile, processHotelHover]);

  const handleMapLoad = useCallback(() => setMapReady(true), []);
  const handleCloseModal = useCallback(() => setSelectedHotelForModal(null), []);

  const handleHotelSelect = useCallback((hotel: ClientHotel, source: 'list' | 'map' = 'list') => {
    if (isMobile) {
      if (source === 'list') { // Tap from BottomSheet or other list components
        // First update map focus state directly to ensure it stays focused
        setMapFocusState({
          type: 'match_found', // Using match_found to ensure consistent behavior
          centerCoordinates: [hotel.lng, hotel.lat],
          zoomLevel: ZOOM_LEVELS.HOTEL,
          focusedHotelId: hotel.id
        });
        
        // Explicitly set active hotel ID for mobile list selection
        setActiveHotel(hotel.id, 'sidebar_hover');
        
        // Then handle location retrieval (which may trigger other state changes)
        handleLocationRetrieved({
          lat: hotel.lat,
          lng: hotel.lng,
          placeName: hotel.name,
          hotelName: hotel.name,
          mapboxBbox: undefined,
          featureType: 'poi',
          category: '',
        });
        
        bottomSheetRef.current?.snapToState('peek');
        
        // Ensure active hotel state persists after location change
        setTimeout(() => {
          setActiveHotel(hotel.id, 'sidebar_hover');
        }, 100);
      } else { // source === 'map' (Tap on map marker)
        if (hotel.id === uiState.activeHotelId) { // Tapped the currently focused/selected or API matched hotel marker
          setSelectedHotelForModal(hotel);
          bottomSheetRef.current?.snapToState('closed'); // Close sheet to give modal focus
        } else { // Tapped a *different* marker on the map
          handleLocationRetrieved({
            lat: hotel.lat,
            lng: hotel.lng,
            placeName: hotel.name,
            hotelName: hotel.name,
            mapboxBbox: undefined,
            featureType: 'poi',
            category: '',
          });
          bottomSheetRef.current?.snapToState('peek');
        }
      }
    } else {
      // Desktop behavior: open modal
      setSelectedHotelForModal(hotel);
    }
  }, [isMobile, handleLocationRetrieved, bottomSheetRef, uiState.activeHotelId, setActiveHotel, setMapFocusState]);

  useEffect(() => {
    if (mapRef.current && mapReady && !initialPaddingSet) {
      let PADDING_BOTTOM = 0;
      if (isMobile) {
        if (isPanelOpen) { 
          const peekVh = 25;
          PADDING_BOTTOM = (peekVh * window.innerHeight) / 100;
          setCurrentBottomSheetState('peek');
        } else {
          setCurrentBottomSheetState('closed');
        }
      }
      // Calculate sidebar width based on window width
      const sidebarWidthPx = (window.innerWidth * DESKTOP_SIDEBAR_WIDTH_PERCENTAGE) / 100;
      const basePadding = {
        left: !isMobile && isPanelOpen ? sidebarWidthPx : 0,
        right: 0,
        top: isMobile ? MOBILE_SEARCH_BAR_HEIGHT : 0
      };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: PADDING_BOTTOM }, duration: 0 });
      setInitialPaddingSet(true);
      setTimeout(() => mapRef.current?.resize(), 50); 
    }
  }, [mapReady, isPanelOpen, initialPaddingSet, isMobile]);

  useEffect(() => {
    if (mapRef.current && mapReady) {
      setTimeout(() => mapRef.current?.resize(), 100); 
    }
  }, [isMobile, mapReady]);

  const handlePanelToggle = () => {
    const newIsOpen = !isPanelOpen;
    setIsPanelOpen(newIsOpen);
    if (isMobile) {
      setCurrentBottomSheetState(newIsOpen ? 'peek' : 'closed');
    } else {
      if (mapRef.current && mapReady) {
        // Calculate sidebar width based on window width
        const sidebarWidthPx = (window.innerWidth * DESKTOP_SIDEBAR_WIDTH_PERCENTAGE) / 100;
        const targetPaddingLeft = newIsOpen ? sidebarWidthPx : 0;
        const basePadding = { left: targetPaddingLeft, right: 0, top: 0 };
        mapRef.current.easeTo({ padding: { ...basePadding, bottom: 0 }, duration: 500, easing: cubicBezier(0.4, 0, 0.2, 1) });
        setTimeout(() => mapRef.current?.resize(), 550);
      }
    }
  };

  const handleBottomSheetStateChange = useCallback((newState: BottomSheetState, heightPx: number) => {
    setCurrentBottomSheetState(newState);
    if (mapRef.current && mapReady && isMobile) {
      const basePadding = { left: 0, right: 0, top: MOBILE_SEARCH_BAR_HEIGHT };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: heightPx }, duration: 300, easing: cubicBezier(0.4, 0, 0.2, 1) });
      setTimeout(() => mapRef.current?.resize(), 350); 
    }
    if (newState === 'closed' && isPanelOpen) setIsPanelOpen(false);
    if ((newState === 'peek' || newState === 'full') && !isPanelOpen ) setIsPanelOpen(true);
  }, [mapReady, isMobile, isPanelOpen]);

  // Effect to handle map centering on sidebar hover
  useEffect(() => {
    if (uiState.interactionSource === 'sidebar_hover' && uiState.activeHotelId !== null) {
      const activeHotel = displayedHotels.find(h => h.id === uiState.activeHotelId);
      if (activeHotel) {
        setMapFocusState(prev => ({
          ...prev,
          type: 'hover_focus', // Can use 'hover_focus' or a more specific type if needed
          centerCoordinates: [activeHotel.lng, activeHotel.lat],
          // Optionally adjust zoom, or keep previous zoom:
          // zoom: ZOOM_LEVELS.HOTEL, 
          focusedHotelId: activeHotel.id
        }));
      }
    }
    // If interactionSource is no longer sidebar_hover, or activeHotelId is null,
    // we don't necessarily revert the map focus here, as other interactions might take precedence
    // or the user might have manually panned.
    // The map will naturally update based on subsequent searches or explicit map interactions.
  }, [uiState.activeHotelId, uiState.interactionSource, displayedHotels, setMapFocusState]);

  // Scroll-to-view logic - ensure this only runs for map_hover or initial_match to avoid conflicts
  useEffect(() => {
    if (uiState.activeHotelId === null) return;
    // Only scroll if interaction came from map or was an initial match to prevent scroll fights with sidebar hover
    if (uiState.interactionSource === 'map_hover' || uiState.interactionSource === 'initial_match') {
        const scrollDelay = isMobile ? 300 : 50;
        setTimeout(() => {
          const hotelCard = document.querySelector(`[data-hotel-id="${uiState.activeHotelId}"]`);
          if (!hotelCard) return;
          const scrollContainer = isMobile 
            ? document.querySelector('.bottom-sheet-content')
            : document.querySelector('.overflow-y-auto');
          if (!scrollContainer) return;
          hotelCard.scrollIntoView({ behavior: 'smooth', block: isMobile ? 'start' : 'center' });
        }, scrollDelay);
    }
  }, [uiState.activeHotelId, uiState.interactionSource, isMobile]); // Added interactionSource

  const initialSheetStateForMobile = isPanelOpen ? 'peek' : 'closed';

  const currentCityNameForSearch = currentIntent.rawMapboxFeature?.placeName || currentIntent.searchTerm || '';

  return (
    <div className="relative h-screen w-full overflow-hidden bg-gray-100">
      {isMobile && (
        <div className="fixed top-0 left-0 right-0 z-50 flex justify-center pt-4 px-4 pointer-events-none">
          <div className="w-full max-w-md pointer-events-auto flex items-center gap-2">
            <div className="flex-1">
              <CitySearchInput
                onLocationRetrieved={handleLocationRetrieved} // Directly from useSearch()
                onNoResultsFound={() => {}}
                isLoading={isLoadingHotels} 
                className="bg-white p-3 rounded-xl shadow-xl w-full"
                initialValue={currentCityNameForSearch} // Use derived city name
              />
            </div>
            <FilterPanel
              isMobile
              activeFilters={activeFilters}
              onFiltersChange={() => setShowFilters(true)}
            />
          </div>
        </div>
      )}

      {!isMobile && (
        <aside
          className={cn(
            "absolute z-20 border bg-background/95 backdrop-blur-sm",
            "shadow-[0_8px_30px_rgb(0,0,0,0.12)]",
            "transition-all duration-700 ease-in-out",
            "flex flex-col",
            "left-4 top-4 bottom-4 w-1/3 rounded-3xl",
            !isPanelOpen && "-translate-x-full"
          )}
        >
          <div className={cn(
            "p-6 flex items-center space-x-2",
            isPanelOpen && 'pr-14' 
          )}>
            <CitySearchInput
              onLocationRetrieved={handleLocationRetrieved}
              onNoResultsFound={() => {}}
              isLoading={isLoadingHotels} 
              className="w-full" 
              initialValue={currentCityNameForSearch}
            />
          </div>
          <div className="flex-1 overflow-y-auto px-4 py-2">
            <HotelListPanel 
              hotels={displayedHotels}
              onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
              isMobile={isMobile}
              activeFilters={activeFilters}
              onFiltersChange={setActiveFilters}
              onMobileFilterButtonClick={() => {}}
            />
          </div>

          <Button
            variant="secondary"
            size="icon"
            className={cn(
              "absolute top-2 left-[100%] ml-[5px]",
              "z-30 h-10 w-10 rounded-full",
              "bg-background/95 shadow-lg backdrop-blur-sm hover:bg-background/80",
              "transition-all duration-500 ease-out"
            )}
            onClick={handlePanelToggle}
            disabled={!mapReady}
          >
            <ChevronLeft
              className="h-4 w-4 transition-transform duration-500 ease-out"
              style={{ transform: isPanelOpen ? 'rotate(0deg)' : 'rotate(180deg)' }}
            />
          </Button>
        </aside>
      )}

      {isMobile && (
        <BottomSheet 
          ref={bottomSheetRef}
          hotels={displayedHotels}
          initialState={initialSheetStateForMobile}
          onStateChange={handleBottomSheetStateChange}
          onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
        />
      )}

      <div className={cn(
        "absolute inset-0 z-10",
        isMobile ? `top-[${MOBILE_SEARCH_BAR_HEIGHT}px]` : "top-0"
      )}>
        <MapboxMap 
          hotels={displayedHotels}
          externalMapRef={mapRef} 
          onMarkerClick={(hotel) => handleHotelSelect(hotel, 'map')}
          onMapLoad={handleMapLoad}
          isMobile={isMobile}
          onMarkerHover={handleMapMarkerHover}
          mapReady={mapReady}
          mapFocusProps={{
            center: mapFocusState.centerCoordinates,
            zoom: mapFocusState.zoomLevel,
            highlightType: mapFocusState.type,
            highlightHotelId: uiState.activeHotelId,
            noMatchSearchTerm: mapFocusState.searchTermDisplay
          }}
        />
      </div>

      {selectedHotelForModal && (
        <HotelDetailModal 
          hotel={selectedHotelForModal} 
          onClose={handleCloseModal} 
        />
      )}

      {/* Mobile Filter Modal */}
      {isMobile && (
        <FilterModal
          isOpen={showFilters}
          onClose={() => setShowFilters(false)}
          activeFilters={activeFilters}
          onApplyFilters={(newFilters) => {
            setActiveFilters(newFilters);
            setShowFilters(false);
          }}
        />
      )}
    </div>
  );
}

export default function HotelSearchPage() {
  return (
    <UIInteractionProvider>
      <SearchProvider>
        <HotelSearchPageContent />
      </SearchProvider>
    </UIInteractionProvider>
  );
}
