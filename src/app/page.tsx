"use client";

import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { ChevronLeft, FilterIcon } from 'lucide-react';
import { Button } from '@/app/components/ui/button';
import { cn, cubicBezier } from '@/lib/utils';
import MapboxMap from '@/app/components/MapboxMap';
import type { Map as MapboxMapType } from 'mapbox-gl';
import { useQuery } from '@tanstack/react-query';
import ListView from '@/app/components/ListView';
import ViewToggle, { ViewMode } from '@/app/components/ViewToggle';
import { ClientHotel } from '@/lib/pelotonAPI';
import { ViewModeProvider, useViewMode } from '@/app/contexts/ViewModeContext';
import HotelDetailModal from '@/app/components/HotelDetailModal';
import BottomSheet, { BottomSheetState } from '@/app/components/BottomSheet';
import { FilterChips, Filters } from '@/app/components/FilterChips';
import dynamic from 'next/dynamic';
import { toast } from 'sonner';
import { SearchProvider, useSearch, ZOOM_LEVELS } from '@/app/contexts/SearchContext';
import HotelListPanel from '@/app/components/HotelListPanel';
import type { BottomSheetHandle } from '@/app/components/BottomSheet';

// Dynamically import MapboxSearchInput with SSR turned off
const DynamicMapboxSearchInput = dynamic(
  () => import('@/app/components/CitySearchInput'),
  { ssr: false, loading: () => <p className="p-3 rounded-xl shadow-xl w-full bg-gray-200 animate-pulse">Loading Search...</p> }
);

// Define primary loyalty programs, could also be imported from FilterChips if kept there
const PRIMARY_LOYALTY_PROGRAMS = [
  "Accor Le Club", "Best Western Rewards", "Choice Privileges", "Hilton Honors", 
  "IHG Rewards Club", "Marriott Bonvoy", "Radisson Rewards", "World of Hyatt", "Wyndham Rewards"
];

const MOBILE_BREAKPOINT = 768;
const DESKTOP_SIDEBAR_WIDTH = 420;
const MOBILE_SEARCH_BAR_HEIGHT = 60; // Approximate height for the search bar on mobile

// Define the API response structure (consistent with api/hotels/route.ts)
interface HotelsApiResponse {
  hotels: ClientHotel[];
  cityCenter?: [number, number];
  matchedHotel?: ClientHotel | null;
  matchConfidence?: number | null;
  cityBbox?: string | null; // Bbox used/generated by API for this search
}

function HotelSearchPageContent() {
  const [isPanelOpen, setIsPanelOpen] = useState(true);
  const [hoveredHotelId, setHoveredHotelId] = useState<number | null>(null);
  const isHoverFromMap = useRef(false); // Changed from useState to useRef
  const [mapReady, setMapReady] = useState(false);
  const [initialPaddingSet, setInitialPaddingSet] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  
  const [activeFilters, setActiveFilters] = useState<Filters>({
    inRoom: false,
    inGym: false,
    loyaltyPrograms: [],
  });
  
  const { viewMode, setViewMode } = useViewMode();
  const { searchContextState, handleLocationRetrieved } = useSearch();
  const { currentIntent, needsFreshHotels } = searchContextState;

  // Local state for the cityBbox returned by the API, for potential reuse
  const [apiProvidedCityBbox, setApiProvidedCityBbox] = useState<string | null>(null);
  // Selected hotel for the modal (distinct from selectedHotelNameForQuery in intent)
  const [selectedHotelForModal, setSelectedHotelForModal] = useState<ClientHotel | null>(null);

  // New state for no-match hotel searches
  const [noMatchSearchDetails, setNoMatchSearchDetails] = useState<{ lat: number; lng: number; searchTerm: string } | null>(null);

  const mapRef = useRef<MapboxMapType | null>(null);
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const [isMobile, setIsMobile] = useState(false);
  const [currentBottomSheetState, setCurrentBottomSheetState] = useState<BottomSheetState>('closed');
  const bottomSheetRef = useRef<BottomSheetHandle | null>(null);

  const cityCenterForMapPan = useRef<[number, number] | undefined>(undefined); // To store city center for no-match pan

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const { 
    data: apiResponse, 
    isLoading: isLoadingHotels, 
    isError: isFetchError, 
    error: fetchError,
    isSuccess: isFetchSuccess,
  } = useQuery<HotelsApiResponse, Error>({
    queryKey: [
      'hotels',
      currentIntent.location?.lat,
      currentIntent.location?.lng,
      currentIntent.searchType,
      currentIntent.selectedHotelNameForQuery, // Part of key if it's a hotel search
      needsFreshHotels // Important for cache busting/API cache behavior
    ],
    queryFn: async () => {
      if (!currentIntent.location) return { hotels: [], cityBbox: null }; // Default empty response
      
      const { lat, lng } = currentIntent.location;
      let apiUrl = `/api/hotels?lat=${lat}&lng=${lng}`;
      
      if (currentIntent.searchTerm) {
        apiUrl += `&searchTerm=${encodeURIComponent(currentIntent.searchTerm)}`;
      }
      
      if (currentIntent.searchType) {
        apiUrl += `&featureType=${encodeURIComponent(currentIntent.searchType === 'hotel' ? 'poi' : 'place')}`;
      }
      
      if (currentIntent.searchType === 'hotel' && currentIntent.selectedHotelNameForQuery) {
        apiUrl += `&freeText=${encodeURIComponent(currentIntent.selectedHotelNameForQuery)}`;
      }
      
      // Use the API-provided bbox from PREVIOUS call if available and not a "fresh" request for this intent
      if (apiProvidedCityBbox && !needsFreshHotels) {
        apiUrl += `&cityBbox=${encodeURIComponent(apiProvidedCityBbox)}`;
      } else if (currentIntent.mapboxFeatureBbox && !needsFreshHotels) {
        // If it's not a fresh search and no apiProvidedCityBbox, but current intent has mapbox one (e.g. first city search)
        apiUrl += `&cityBbox=${encodeURIComponent(currentIntent.mapboxFeatureBbox)}`;
      }

      console.log('[HotelsQuery] fetching', { 
        apiUrl,
        isHotelSearchQuery: currentIntent.searchType === 'hotel',
        reusingApiBbox: !!(apiProvidedCityBbox && !needsFreshHotels),
        reusingMapboxBbox: !!(currentIntent.mapboxFeatureBbox && !needsFreshHotels && !apiProvidedCityBbox)
      });

      if (apiProvidedCityBbox && !needsFreshHotels && currentIntent.searchType === 'hotel') {
        toast.success('Using cached city data for faster results! âš¡');
      }

      const response = await fetch(apiUrl);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: "Unknown error fetching hotels" }));
        throw new Error(errorData.message || `Error: ${response.status}`);
      }
      const data: HotelsApiResponse = await response.json(); 

      console.log('[HotelsQuery] response', { 
        hotelsCount: data.hotels.length, 
        matchedHotelId: data.matchedHotel?.id, 
        matchConfidence: data.matchConfidence,
        hasCityBbox: !!data.cityBbox
      });
      
      return data;
    },
    enabled: !!currentIntent.location, // Only run query if a location is part of the intent
    retry: 1,
  });

  // Extracted data from apiResponse for consumption by UI
  const hotelsFromApi = useMemo(() => apiResponse?.hotels || [], [apiResponse]);
  const matchedHotelFromApi = useMemo(() => apiResponse?.matchedHotel, [apiResponse]);

  // Handle successful API response: update apiProvidedCityBbox for potential reuse
  useEffect(() => {
    if (isFetchSuccess && apiResponse) {
      if (apiResponse.cityBbox) {
        setApiProvidedCityBbox(apiResponse.cityBbox);
      }
      if (apiResponse.cityCenter) {
        cityCenterForMapPan.current = apiResponse.cityCenter;
      }

      if (currentIntent.searchType === 'hotel') {
        if (apiResponse.matchedHotel && apiResponse.matchedHotel.id) {
          // Hotel Match Found
          setNoMatchSearchDetails(null); 
          isHoverFromMap.current = true; 
          setHoveredHotelId(apiResponse.matchedHotel.id);
          if (isMobile && bottomSheetRef.current && currentBottomSheetState === 'closed') {
            bottomSheetRef.current.snapToState('peek'); 
          }
        } else {
          // No Hotel Match Found for a specific hotel search
          if (currentIntent.location && currentIntent.searchTerm) {
            setNoMatchSearchDetails({ 
              lat: currentIntent.location.lat, 
              lng: currentIntent.location.lng, 
              searchTerm: currentIntent.searchTerm 
            });
            toast.error(`No Peloton found at "${currentIntent.searchTerm}". Showing nearby options.`);
            setHoveredHotelId(null); // Clear any hover from previous search
            setSelectedHotelForModal(null); // Ensure no modal is open
          }
        }
      } else {
        // City Search (not a specific hotel search)
        setNoMatchSearchDetails(null); // Clear no-match state on city searches
      }

    } else if (isFetchError && fetchError) {
      console.error("Failed to fetch hotels:", fetchError.message);
      // hotelsFromApi will be an empty array due to its memoized default.
    }
  }, [isFetchSuccess, apiResponse, isFetchError, fetchError, currentIntent.searchType, currentIntent.location, currentIntent.searchTerm, isMobile, currentBottomSheetState]);

  // Reset states when the core search location in the intent changes significantly
  useEffect(() => {
    if (needsFreshHotels) { // This flag is set in SearchContext when location changes significantly
        setApiProvidedCityBbox(null); // Clear any bbox from a previous city
        setActiveFilters({ inRoom: false, inGym: false, loyaltyPrograms: [] });
        setShowFilters(false);
        setHoveredHotelId(null);
        setSelectedHotelForModal(null); // Clear modal for any new search
    }
    // When a new location is set (even if not "fresh"), always clear the modal
    // to avoid showing details from a previous search context.
    if (currentIntent.location) {
      setSelectedHotelForModal(null);
    }

  }, [currentIntent.location, needsFreshHotels]);

  const filterChipOptions = useMemo(() => {
    if (!hotelsFromApi) return [...PRIMARY_LOYALTY_PROGRAMS, "Other"];
    
    const options = new Set<string>([...PRIMARY_LOYALTY_PROGRAMS]);
    let hasActualOther = false;
    hotelsFromApi.forEach(hotel => {
      if (hotel.loyaltyProgram === "Other") {
        hasActualOther = true;
        if (hotel.brand && !PRIMARY_LOYALTY_PROGRAMS.includes(hotel.brand)) {
          options.add(hotel.brand);
        }
      } else if (hotel.loyaltyProgram && !PRIMARY_LOYALTY_PROGRAMS.includes(hotel.loyaltyProgram)){
        options.add(hotel.loyaltyProgram);
      }
    });
    if (hasActualOther || hotelsFromApi.some(h => h.loyaltyProgram === "Other")) {
        options.add("Other");
    }
    return Array.from(options).sort((a, b) => {
        if (a === "Other") return 1;
        if (b === "Other") return -1;
        return a.localeCompare(b);
    });
  }, [hotelsFromApi]);

  const displayedHotels = useMemo(() => {
    const isHotelSearchIntent = currentIntent.searchType === 'hotel';
    const matchedHotelId = matchedHotelFromApi?.id;

    if (isHotelSearchIntent && matchedHotelId) {
      const matched = hotelsFromApi.find(h => h.id === matchedHotelId);
      if (matched) {
        return [matched, ...hotelsFromApi.filter(h => h.id !== matchedHotelId)];
      }
    }
    
    let filtered = [...hotelsFromApi];
    if (activeFilters.loyaltyPrograms.length > 0) {
      filtered = filtered.filter(hotel => {
        return activeFilters.loyaltyPrograms.some(filterProgram => {
          if (filterProgram === "Other") return hotel.loyaltyProgram === "Other";
          if (PRIMARY_LOYALTY_PROGRAMS.includes(filterProgram)) return hotel.loyaltyProgram === filterProgram;
          return hotel.brand === filterProgram && (hotel.loyaltyProgram === "Other" || hotel.loyaltyProgram === hotel.brand);
        });
      });
    }
    if (activeFilters.inRoom) filtered = filtered.filter(hotel => hotel.in_room);
    if (activeFilters.inGym) filtered = filtered.filter(hotel => hotel.in_gym);

    filtered.sort((a, b) => {
      if (a.in_room !== b.in_room) return a.in_room ? -1 : 1;
      if (a.in_gym !== b.in_gym) return a.in_gym ? -1 : 1;
      if (a.distance_m === null) return 1;
      if (b.distance_m === null) return -1;
      return a.distance_m - b.distance_m;
    });
    return filtered;
  }, [hotelsFromApi, activeFilters, currentIntent.searchType, matchedHotelFromApi]);

  const handleHotelHover = useCallback((id: number | null) => {
    if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);
    hoverTimeoutRef.current = setTimeout(() => {
      setHoveredHotelId(id);
      isHoverFromMap.current = false;
    }, 75);
  }, []);

  const handleMapMarkerHover = useCallback((id: number | null) => {
    if (isMobile && id === null) return;
    setHoveredHotelId(id);
    isHoverFromMap.current = true;
    if (isMobile && id !== null) {
      if (!isPanelOpen) setIsPanelOpen(true);
      if (currentBottomSheetState === 'closed') setCurrentBottomSheetState('peek');
    }
  }, [isMobile, isPanelOpen, currentBottomSheetState]);

  const handleMapLoad = useCallback(() => setMapReady(true), []);
  const handleCloseModal = useCallback(() => setSelectedHotelForModal(null), []);

  const handleHotelSelect = useCallback((hotel: ClientHotel, source: 'list' | 'map' = 'list') => {
    if (isMobile) {
      if (source === 'list') { // Tap from BottomSheet or other list components
        handleLocationRetrieved({
          lat: hotel.lat,
          lng: hotel.lng,
          placeName: hotel.name,
          hotelName: hotel.name,
          mapboxBbox: undefined,
          featureType: 'poi',
          category: '',
        });
        setHoveredHotelId(hotel.id);
        setSelectedHotelForModal(null);
        bottomSheetRef.current?.snapToState('peek');
      } else { // source === 'map' (Tap on map marker)
        if (hotel.id === hoveredHotelId || hotel.id === matchedHotelFromApi?.id) { // Tapped the currently focused/selected or API matched hotel marker
          setSelectedHotelForModal(hotel);
          bottomSheetRef.current?.snapToState('closed'); // Close sheet to give modal focus
        } else { // Tapped a *different* marker on the map
          handleLocationRetrieved({
            lat: hotel.lat,
            lng: hotel.lng,
            placeName: hotel.name,
            hotelName: hotel.name,
            mapboxBbox: undefined,
            featureType: 'poi',
            category: '',
          });
          setHoveredHotelId(hotel.id);
          setSelectedHotelForModal(null);
          bottomSheetRef.current?.snapToState('peek');
        }
      }
    } else {
      // Desktop behavior: open modal
      setSelectedHotelForModal(hotel);
    }
  }, [isMobile, handleLocationRetrieved, bottomSheetRef, hoveredHotelId, matchedHotelFromApi]); 

  useEffect(() => {
    if (mapRef.current && mapReady && !initialPaddingSet) {
      let PADDING_BOTTOM = 0;
      if (isMobile) {
        if (isPanelOpen) { 
          const peekVh = 25;
          PADDING_BOTTOM = (peekVh * window.innerHeight) / 100;
          setCurrentBottomSheetState('peek');
        } else {
          setCurrentBottomSheetState('closed');
        }
      }
      const basePadding = {
        left: !isMobile && isPanelOpen ? DESKTOP_SIDEBAR_WIDTH : 0,
        right: 0,
        top: isMobile ? MOBILE_SEARCH_BAR_HEIGHT : 0
      };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: PADDING_BOTTOM }, duration: 0 });
      setInitialPaddingSet(true);
      setTimeout(() => mapRef.current?.resize(), 50); 
    }
  }, [mapReady, isPanelOpen, initialPaddingSet, isMobile]);

  useEffect(() => {
    if (mapRef.current && mapReady) {
      setTimeout(() => mapRef.current?.resize(), 100); 
    }
  }, [isMobile, mapReady]);

  const handlePanelToggle = () => {
    const newIsOpen = !isPanelOpen;
    setIsPanelOpen(newIsOpen);
    if (isMobile) {
      setCurrentBottomSheetState(newIsOpen ? 'peek' : 'closed');
    } else {
      if (mapRef.current && mapReady) {
        const targetPaddingLeft = newIsOpen ? DESKTOP_SIDEBAR_WIDTH : 0;
        const basePadding = { left: targetPaddingLeft, right: 0, top: 0 };
        mapRef.current.easeTo({ padding: { ...basePadding, bottom: 0 }, duration: 500, easing: cubicBezier(0.4, 0, 0.2, 1) });
        setTimeout(() => mapRef.current?.resize(), 550);
      }
    }
  };

  const handleBottomSheetStateChange = useCallback((newState: BottomSheetState, heightPx: number) => {
    setCurrentBottomSheetState(newState);
    if (mapRef.current && mapReady && isMobile) {
      const basePadding = { left: 0, right: 0, top: MOBILE_SEARCH_BAR_HEIGHT };
      mapRef.current.easeTo({ padding: { ...basePadding, bottom: heightPx }, duration: 300, easing: cubicBezier(0.4, 0, 0.2, 1) });
      setTimeout(() => mapRef.current?.resize(), 350); 
    }
    if (newState === 'closed' && isPanelOpen) setIsPanelOpen(false);
    if ((newState === 'peek' || newState === 'full') && !isPanelOpen ) setIsPanelOpen(true);
  }, [mapReady, isMobile, isPanelOpen]);

  useEffect(() => {
    if (hoveredHotelId === null || !isHoverFromMap.current) return;
    const scrollDelay = isMobile ? 300 : 50;
    setTimeout(() => {
      const hotelCard = document.querySelector(`[data-hotel-id="${hoveredHotelId}"]`);
      if (!hotelCard) return;
      const scrollContainer = isMobile 
        ? document.querySelector('.bottom-sheet-content')
        : document.querySelector('.overflow-y-auto');
      if (!scrollContainer) return;
      hotelCard.scrollIntoView({ behavior: 'smooth', block: isMobile ? 'start' : 'center' });
    }, scrollDelay);
  }, [hoveredHotelId, isMobile, isHoverFromMap]);

  const handleViewChange = (newView: ViewMode) => {
    setViewMode(newView);
    if (isMobile && newView === 'map' && !isPanelOpen) {
      setIsPanelOpen(true); 
      setCurrentBottomSheetState('peek');
    }
  };

  const initialSheetStateForMobile = isPanelOpen ? 'peek' : 'closed';

  const listViewContent = (
    <ListView 
      hotels={displayedHotels} // Uses derived state
      isLoading={isLoadingHotels} // Uses direct useQuery state
      onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
    />
  );
  
  const currentCityNameForSearch = currentIntent.rawMapboxFeature?.placeName || currentIntent.searchTerm || '';

  // Effect to update searchLocation for MapboxMap when a hotel is matched
  // This ensures the map centers on the matched hotel, not the original geocoded POI location if different.
  const mapSearchLocation = useMemo(() => {
    if (currentIntent.searchType === 'hotel' && matchedHotelFromApi) {
      return { lat: matchedHotelFromApi.lat, lng: matchedHotelFromApi.lng };
    }
    // For no-match, we might want to pan to city center if available, or stick to original search intent location
    if (noMatchSearchDetails && cityCenterForMapPan.current) {
      // return { lat: cityCenterForMapPan.current[1], lng: cityCenterForMapPan.current[0] }; // Option to pan to city center
    }
    return currentIntent.location; // Default to current search intent's location
  }, [currentIntent.location, currentIntent.searchType, matchedHotelFromApi, noMatchSearchDetails]);

  const mapZoomLevel = useMemo(() => {
    if (noMatchSearchDetails) {
      return ZOOM_LEVELS.NO_MATCH_CITY_OVERVIEW;
    }
    if (currentIntent.searchType === 'hotel') {
      return ZOOM_LEVELS.HOTEL;
    }
    return ZOOM_LEVELS.CITY; // Default to city zoom if not a hotel search or noMatch
  }, [currentIntent.searchType, noMatchSearchDetails]);

  return (
    <div className="relative h-screen w-full overflow-hidden bg-gray-100">
      {isMobile && (
        <div className="fixed top-0 left-0 right-0 z-50 flex justify-center pt-4 px-4 pointer-events-none">
          <div className="w-full max-w-md pointer-events-auto">
            <DynamicMapboxSearchInput
              onLocationRetrieved={handleLocationRetrieved} // Directly from useSearch()
              onNoResultsFound={() => {}}
              isLoading={isLoadingHotels} 
              className="bg-white p-3 rounded-xl shadow-xl w-full"
              initialValue={currentCityNameForSearch} // Use derived city name
            />
          </div>
        </div>
      )}

      {!isMobile && (
        <aside
          className={cn(
            "absolute z-20 border bg-background/95 backdrop-blur-sm",
            "shadow-[0_8px_30px_rgb(0,0,0,0.12)]",
            "transition-all duration-700 ease-in-out",
            "flex flex-col",
            viewMode === "list" 
              ? "inset-4 rounded-xl"
              : `left-4 top-4 bottom-4 w-[${DESKTOP_SIDEBAR_WIDTH}px] rounded-3xl`,
            viewMode === 'map' && !isPanelOpen && "-translate-x-full"
          )}
        >
          <div className={cn(
            "p-6 flex items-center space-x-2",
            viewMode === 'map' && isPanelOpen && 'pr-14' 
          )}>
            <DynamicMapboxSearchInput
              onLocationRetrieved={handleLocationRetrieved}
              onNoResultsFound={() => {}}
              isLoading={isLoadingHotels} 
              className="w-full" 
              initialValue={currentCityNameForSearch}
            />
          </div>
          <div className="flex-1 overflow-y-auto px-4 py-2">
            {viewMode === "list" ? (
              <ListView 
                hotels={displayedHotels}
                isLoading={isLoadingHotels}
                onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
              />
            ) : (
              <HotelListPanel 
                hotels={displayedHotels}
                onHotelHover={handleHotelHover} 
                onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
                hoveredHotelId={hoveredHotelId} 
                isMobile={isMobile} 
              />
            )}
          </div>

          {viewMode === 'map' && (
            <Button
              variant="secondary"
              size="icon"
              className={cn(
                "absolute top-2 left-[100%] ml-[5px]",
                "z-30 h-10 w-10 rounded-full",
                "bg-background/95 shadow-lg backdrop-blur-sm hover:bg-background/80",
                "transition-all duration-500 ease-out"
              )}
              onClick={handlePanelToggle}
              disabled={!mapReady}
            >
              <ChevronLeft
                className="h-4 w-4 transition-transform duration-500 ease-out"
                style={{ transform: isPanelOpen ? 'rotate(0deg)' : 'rotate(180deg)' }}
              />
            </Button>
          )}
        </aside>
      )}

      {isMobile && (
        <BottomSheet 
          ref={bottomSheetRef}
          hotels={displayedHotels}
          initialState={initialSheetStateForMobile}
          onStateChange={handleBottomSheetStateChange}
          onHotelSelect={(hotel) => handleHotelSelect(hotel, 'list')}
          onHotelHover={handleHotelHover}
          hoveredHotelId={hoveredHotelId}
        />
      )}

      <div className={cn(
        "absolute inset-0 z-10",
        isMobile ? `top-[${MOBILE_SEARCH_BAR_HEIGHT}px]` : "top-0",
        (viewMode === "list" && !isMobile) && "opacity-20 pointer-events-none"
      )}>
        <MapboxMap 
          hotels={displayedHotels}
          mapRef={mapRef} 
          hoveredHotelId={hoveredHotelId}
          onMarkerClick={(hotel) => handleHotelSelect(hotel, 'map')}
          onMapLoad={handleMapLoad}
          isMobile={isMobile}
          onMarkerHover={handleMapMarkerHover}
          mapReady={mapReady}
          searchLocation={mapSearchLocation} // Use derived mapSearchLocation
          isHotelSearchIntent={currentIntent.searchType === 'hotel'}
          matchedHotelId={matchedHotelFromApi?.id} 
          noMatchSearchLocation={noMatchSearchDetails} // Pass noMatchSearchDetails to MapboxMap
          mapTargetZoom={mapZoomLevel} // Pass explicit zoom level
        />
      </div>

      <ViewToggle 
        activeView={viewMode}
        onChange={handleViewChange}
        className={cn(
            "absolute z-30 top-8 right-8 bg-white shadow-md rounded-md p-1"
        )}
      />

      {selectedHotelForModal && (
        <HotelDetailModal 
          hotel={selectedHotelForModal} 
          onClose={handleCloseModal} 
        />
      )}

      {viewMode === 'list' && (
        <div className={cn(
          "fixed inset-0 z-30 bg-white dark:bg-gray-900 md:inset-4 md:rounded-xl md:shadow-2xl overflow-y-auto",
          isMobile ? "pt-16" : "pt-4"
        )}>
          <div className={cn(
            "sticky top-0 bg-white dark:bg-gray-900 z-10 px-4 pt-4 pb-2 md:pb-4",
            isMobile ? "fixed w-full top-0 left-0 right-0 shadow-md" : ""
          )}>
             <div className="flex items-center justify-between">
                <DynamicMapboxSearchInput
                  onLocationRetrieved={handleLocationRetrieved}
                  onNoResultsFound={() => {}}
                  isLoading={isLoadingHotels} 
                  className="flex-grow" 
                  initialValue={currentCityNameForSearch}
                />
                 <Button variant="ghost" size="icon" onClick={() => setShowFilters(!showFilters)} className="ml-2">
                  <FilterIcon className="h-5 w-5" />
                </Button>
              </div>
              {showFilters && (
                 <div className="mt-2">
                   <FilterChips activeFilters={activeFilters} onFilterChange={setActiveFilters} availableLoyaltyPrograms={filterChipOptions} />
                </div>
              )}
          </div>
          <div className={isMobile ? "mt-10 md:mt-0" : ""}> 
            {listViewContent}
          </div>
        </div>
      )}
    </div>
  );
}

export default function HotelSearchPage() {
  return (
    <ViewModeProvider>
      <SearchProvider>
        <HotelSearchPageContent />
      </SearchProvider>
    </ViewModeProvider>
  );
}
